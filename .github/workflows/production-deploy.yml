name: 🚀 운영 배포 파이프라인

on:
  push:
    tags:
      - 'v*.*.*'  # v2.1.0 형태의 태그
  release:
    types: [published]
  workflow_dispatch:  # 수동 배포 허용
    inputs:
      environment:
        description: '배포 환경'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: '테스트 스킵 (긴급 배포용)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/vridge-web

permissions:
  contents: read
  packages: write
  deployments: write
  checks: write
  pull-requests: write

jobs:
  # ========================================
  # Stage 1: 배포 전 검증 (Pre-deployment Validation)
  # ========================================
  pre-deployment-validation:
    name: 🔍 배포 전 검증
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      environment: ${{ steps.environment.outputs.environment }}
      should-deploy: ${{ steps.validation.outputs.should-deploy }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 버전 추출
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=$(cat package.json | jq -r '.version')
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "📦 Deploying version: $VERSION"

      - name: 배포 환경 결정
        id: environment
        run: |
          if [[ "${{ github.event.inputs.environment }}" != "" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ $GITHUB_REF == refs/tags/* ]]; then
            if [[ ${{ steps.version.outputs.version }} =~ -beta|-alpha|-rc ]]; then
              ENVIRONMENT="staging"
            else
              ENVIRONMENT="production"
            fi
          else
            ENVIRONMENT="staging"
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "🎯 Target environment: $ENVIRONMENT"

      - name: 배포 승인 확인
        id: validation
        run: |
          ENVIRONMENT="${{ steps.environment.outputs.environment }}"
          
          if [[ "$ENVIRONMENT" == "production" ]]; then
            echo "🚨 Production deployment requires additional validation"
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            
            # 운영 배포 조건 확인
            if [[ "${{ github.event_name }}" == "release" ]] && [[ "${{ github.event.action }}" == "published" ]]; then
              echo "✅ Release published - production deployment approved"
              echo "should-deploy=true" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
              echo "✅ Manual production deployment requested"
              echo "should-deploy=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "✅ Staging deployment approved"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          fi

  # ========================================
  # Stage 2: 보안 검사 (Security Scan)
  # ========================================
  security-scan:
    name: 🔒 보안 검사
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: 의존성 보안 검사
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high

      - name: CodeQL 보안 스캔
        uses: github/codeql-action/init@v3
        with:
          languages: typescript, javascript

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: 보안 취약점 스캔 (npm audit)
        run: |
          echo "🔍 Running npm security audit..."
          npm audit --audit-level=high
          
          # 중요 취약점이 있으면 배포 중단
          VULNERABILITIES=$(npm audit --json | jq '.metadata.vulnerabilities.high + .metadata.vulnerabilities.critical')
          if [ "$VULNERABILITIES" -gt 0 ]; then
            echo "❌ High/Critical vulnerabilities found: $VULNERABILITIES"
            echo "Fix vulnerabilities before deploying to production"
            exit 1
          fi
          
          echo "✅ No high/critical vulnerabilities found"

      - name: CodeQL 분석 완료
        uses: github/codeql-action/analyze@v3

      - name: 시크릿 스캔 (GitLeaks)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ========================================
  # Stage 3: 품질 게이트 (기존 품질 게이트 재실행)
  # ========================================
  quality-gates:
    name: 📊 품질 게이트 검증
    uses: ./.github/workflows/quality-gates.yml
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true' && !inputs.skip_tests
    secrets: inherit

  # ========================================
  # Stage 4: 컨테이너 이미지 빌드 및 푸시
  # ========================================
  build-and-push:
    name: 🏗️ 컨테이너 빌드 및 푸시
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, security-scan]
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: 컨테이너 레지스트리 로그인
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 메타데이터 추출
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=ref,event=branch
            type=sha,prefix=${{ needs.pre-deployment-validation.outputs.version }}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: 멀티 플랫폼 빌더 설정
        uses: docker/setup-buildx-action@v3

      - name: 컨테이너 이미지 빌드 및 푸시
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.pre-deployment-validation.outputs.version }}
            ENVIRONMENT=${{ needs.pre-deployment-validation.outputs.environment }}

      - name: 이미지 정보 출력
        id: image
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "🐳 Built image: $IMAGE"
          echo "📋 Digest: ${{ steps.build.outputs.digest }}"

      - name: 컨테이너 보안 스캔
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ steps.image.outputs.image }}@${{ steps.build.outputs.digest }}'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: 보안 스캔 결과 업로드
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ========================================
  # Stage 5: 스테이징 배포
  # ========================================
  deploy-staging:
    name: 🧪 스테이징 배포
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-and-push]
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    environment: 
      name: staging
      url: https://staging.vridge.vlanet.net
    
    steps:
      - name: 스테이징 환경 배포
        run: |
          echo "🚀 Deploying to staging environment..."
          echo "Image: ${{ needs.build-and-push.outputs.image }}"
          echo "Version: ${{ needs.pre-deployment-validation.outputs.version }}"
          
          # 실제 배포 로직 (예: Kubernetes, Docker Swarm, Vercel 등)
          # kubectl set image deployment/vridge-web vridge-web=${{ needs.build-and-push.outputs.image }}
          
          echo "✅ Staging deployment completed"

      - name: 헬스체크 (스테이징)
        run: |
          echo "🔍 Running health checks on staging..."
          
          # 애플리케이션 시작 대기 (최대 5분)
          for i in {1..30}; do
            if curl -f -s https://staging.vridge.vlanet.net/api/health > /dev/null; then
              echo "✅ Staging application is healthy"
              break
            fi
            echo "⏳ Waiting for application to start... ($i/30)"
            sleep 10
          done
          
          # 기본 API 엔드포인트 테스트
          curl -f https://staging.vridge.vlanet.net/api/health || exit 1
          curl -f https://staging.vridge.vlanet.net/ || exit 1
          
          echo "✅ All health checks passed"

      - name: 스모크 테스트 실행
        run: |
          echo "🧪 Running smoke tests on staging..."
          
          # E2E 스모크 테스트 실행
          npx playwright test --config=playwright.staging.config.ts --project=staging-smoke
          
          echo "✅ Smoke tests passed"

  # ========================================
  # Stage 6: 운영 배포 (승인 필요)
  # ========================================
  deploy-production:
    name: 🌟 운영 배포
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-and-push, deploy-staging]
    if: needs.pre-deployment-validation.outputs.environment == 'production' && needs.pre-deployment-validation.outputs.should-deploy == 'true'
    environment:
      name: production
      url: https://vridge.vlanet.net
    
    steps:
      - name: 운영 배포 시작 알림
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "🚀 Production deployment started",
              "attachments": [{
                "color": "warning",
                "fields": [{
                  "title": "Version",
                  "value": "${{ needs.pre-deployment-validation.outputs.version }}",
                  "short": true
                }, {
                  "title": "Triggered by",
                  "value": "${{ github.actor }}",
                  "short": true
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: 블루-그린 배포 준비
        run: |
          echo "🔄 Preparing blue-green deployment..."
          
          # 현재 활성 슬롯 확인
          CURRENT_SLOT=$(curl -s https://api.vlanet.net/deployment/current-slot || echo "blue")
          TARGET_SLOT=$([ "$CURRENT_SLOT" = "blue" ] && echo "green" || echo "blue")
          
          echo "Current active slot: $CURRENT_SLOT"
          echo "Target deployment slot: $TARGET_SLOT"
          echo "target-slot=$TARGET_SLOT" >> $GITHUB_ENV

      - name: 운영 환경 배포
        run: |
          echo "🌟 Deploying to production environment..."
          echo "Target slot: ${{ env.target-slot }}"
          echo "Image: ${{ needs.build-and-push.outputs.image }}"
          
          # 실제 운영 배포 로직
          # kubectl set image deployment/vridge-web-${{ env.target-slot }} vridge-web=${{ needs.build-and-push.outputs.image }}
          
          echo "✅ Production deployment to ${{ env.target-slot }} completed"

      - name: 헬스체크 (운영)
        run: |
          echo "🔍 Running health checks on production (${{ env.target-slot }} slot)..."
          
          # 애플리케이션 시작 대기 (최대 10분)
          for i in {1..60}; do
            if curl -f -s https://${{ env.target-slot }}.vridge.vlanet.net/api/health > /dev/null; then
              echo "✅ Production application is healthy"
              break
            fi
            echo "⏳ Waiting for application to start... ($i/60)"
            sleep 10
          done
          
          # 상세 헬스체크
          curl -f https://${{ env.target-slot }}.vridge.vlanet.net/api/health || exit 1
          curl -f https://${{ env.target-slot }}.vridge.vlanet.net/ || exit 1
          
          # 데이터베이스 연결 확인
          curl -f https://${{ env.target-slot }}.vridge.vlanet.net/api/db-health || exit 1
          
          echo "✅ All production health checks passed"

      - name: 운영 스모크 테스트
        run: |
          echo "🧪 Running production smoke tests..."
          
          # 운영 환경 스모크 테스트
          PLAYWRIGHT_BASE_URL=https://${{ env.target-slot }}.vridge.vlanet.net \
          npx playwright test --config=playwright.production.config.ts --project=production-smoke
          
          echo "✅ Production smoke tests passed"

      - name: 트래픽 스위칭 (Blue-Green)
        run: |
          echo "🔄 Switching production traffic to ${{ env.target-slot }} slot..."
          
          # 로드밸런서 트래픽 스위칭
          # kubectl patch service vridge-web-lb -p '{"spec":{"selector":{"slot":"${{ env.target-slot }}"}}}'
          
          # DNS 업데이트 (필요시)
          # 또는 CDN 설정 업데이트
          
          echo "✅ Traffic switched to ${{ env.target-slot }} slot"

      - name: 최종 검증
        run: |
          echo "🔍 Final production verification..."
          
          # 메인 도메인으로 최종 확인
          curl -f https://vridge.vlanet.net/api/health || exit 1
          curl -f https://vridge.vlanet.net/ || exit 1
          
          # 성능 메트릭 확인
          # 실제로는 APM 도구나 모니터링 시스템에서 확인
          
          echo "✅ Production deployment verified successfully"

      - name: 이전 슬롯 정리 (30분 대기 후)
        run: |
          echo "🧹 Scheduling cleanup of previous slot..."
          echo "Previous slot will be cleaned up after 30 minutes for rollback safety"
          
          # 백그라운드에서 30분 후 이전 슬롯 정리
          # (실제로는 별도의 크론잡이나 스케줄러 사용 권장)

  # ========================================
  # Stage 7: 배포 후 모니터링
  # ========================================
  post-deployment-monitoring:
    name: 📊 배포 후 모니터링
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-production]
    if: needs.pre-deployment-validation.outputs.environment == 'production' && always()
    
    steps:
      - name: 성능 메트릭 수집 대기
        run: |
          echo "⏳ Waiting 5 minutes for performance metrics to stabilize..."
          sleep 300

      - name: Core Web Vitals 모니터링
        run: |
          echo "📊 Monitoring Core Web Vitals..."
          
          # Lighthouse CI로 배포 후 성능 측정
          npx lhci autorun --config=.lighthouserc.production.json
          
          # 성능 임계값 검사
          LCP=$(cat lhci-results.json | jq '.median.firstRun.lcp')
          FID=$(cat lhci-results.json | jq '.median.firstRun.fid // 0')
          CLS=$(cat lhci-results.json | jq '.median.firstRun.cls')
          
          echo "Current Performance:"
          echo "LCP: ${LCP}ms"
          echo "FID: ${FID}ms" 
          echo "CLS: $CLS"
          
          # 성능 저하 감지
          if (( $(echo "$LCP > 3000" | bc -l) )); then
            echo "⚠️ Performance degradation detected: LCP > 3s"
            # Slack 알림이나 자동 롤백 트리거 가능
          fi

      - name: 애플리케이션 메트릭 확인
        run: |
          echo "📈 Checking application metrics..."
          
          # APM 도구나 메트릭 서버에서 데이터 수집
          # 예: 응답시간, 에러율, 처리량 등
          
          ERROR_RATE=$(curl -s https://metrics.vlanet.net/api/error-rate/5m || echo "0")
          RESPONSE_TIME=$(curl -s https://metrics.vlanet.net/api/response-time/5m || echo "0")
          
          echo "5분간 평균 메트릭:"
          echo "Error Rate: ${ERROR_RATE}%"
          echo "Response Time: ${RESPONSE_TIME}ms"
          
          # 임계값 검사
          if (( $(echo "$ERROR_RATE > 1" | bc -l) )); then
            echo "🚨 High error rate detected: ${ERROR_RATE}%"
            exit 1
          fi

      - name: 배포 성공 알림
        uses: 8398a7/action-slack@v3
        if: success()
        with:
          status: success
          text: "🎉 Production deployment successful! Version ${{ needs.pre-deployment-validation.outputs.version }} is now live."
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: 배포 실패 알림 및 롤백 트리거
        if: failure()
        run: |
          echo "🚨 Post-deployment monitoring failed - triggering rollback"
          
          # 자동 롤백 로직
          # kubectl rollout undo deployment/vridge-web-production
          
          # 실패 알림
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-type: application/json' \
            --data '{
              "text": "🚨 Production deployment failure detected!",
              "attachments": [{
                "color": "danger",
                "fields": [{
                  "title": "Version",
                  "value": "${{ needs.pre-deployment-validation.outputs.version }}",
                  "short": true
                }, {
                  "title": "Status", 
                  "value": "Rollback initiated",
                  "short": true
                }]
              }]
            }'

  # ========================================
  # Stage 8: 배포 완료 처리
  # ========================================
  deployment-completion:
    name: ✅ 배포 완료 처리
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-staging, deploy-production, post-deployment-monitoring]
    if: always()
    
    steps:
      - name: 배포 결과 요약
        run: |
          echo "📋 Deployment Summary"
          echo "===================="
          echo "Version: ${{ needs.pre-deployment-validation.outputs.version }}"
          echo "Environment: ${{ needs.pre-deployment-validation.outputs.environment }}"
          echo "Staging: ${{ needs.deploy-staging.result }}"
          echo "Production: ${{ needs.deploy-production.result }}"
          echo "Monitoring: ${{ needs.post-deployment-monitoring.result }}"
          
          if [[ "${{ needs.deploy-production.result }}" == "success" ]] && [[ "${{ needs.post-deployment-monitoring.result }}" == "success" ]]; then
            echo "🎉 Deployment completed successfully!"
          else
            echo "❌ Deployment encountered issues"
          fi

      - name: 배포 기록 업데이트
        run: |
          echo "📝 Updating deployment records..."
          
          # 배포 이력을 데이터베이스나 모니터링 시스템에 기록
          # 예: deployment tracking service 호출
          
          echo "✅ Deployment records updated"

      - name: 문서 업데이트 (자동)
        run: |
          echo "📚 Updating deployment documentation..."
          
          # CHANGELOG.md 자동 업데이트
          # API 문서 버전 업데이트
          # 배포 가이드 최신화
          
          echo "✅ Documentation updated"