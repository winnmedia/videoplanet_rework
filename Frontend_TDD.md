FE 개발지침 — TDD(테스트 주도 개발) 최종본
대상: 프론트엔드 개발자 · 개발 리드 · PM
목적: 디자인·API 의존성으로 인한 병목을 제거하고, 예측 가능한 일정과 품질을 확보합니다.
원칙: Red → Green → Refactor, 의존성 절단(View/Logic 분리, API 모킹, View-Model 우선), 결정론성, 작게·자주.

***프론트엔드 디자인 시 이모지 사용 금지***
***기존 톤앤매너와 대표색상 활용 디자인***

0) 적용 범위 (VideoPlanet 기술 스택 기준)
프레임워크/언어: Next.js 14(App Router), React 18, TypeScript
상태 관리: Redux Toolkit, Redux Persist(민감정보 제외)
네트워크/실시간: Axios, WebSocket(이벤트 시뮬레이션 가능해야 함)
스타일링: SCSS Modules, Styled Components, Ant Design(래핑 컴포넌트 권장)
테스트: Jest, React Testing Library(RTL), Cypress(E2E)
빌드: Webpack 5, SWC Compiler
배포/환경: Vercel(Frontend), Railway(Backend)
CI 게이트(필수): tsc --noEmit, ESLint, Jest, Cypress 스모크


1) 철학과 기본 원칙
테스트가 곧 명세입니다. 요구사항은 테스트로 먼저 표현하고, 코드가 이를 만족하도록 만듭니다.
Red → Green → Refactor를 지킵니다. 실패를 먼저 확인하고, 최소 구현으로 통과시킨 뒤, 안전하게 리팩터합니다.
코어 로직: 항상 TDD (테스트 먼저)
UI 컴포넌트: 복잡도에 따라 유연하게 적용 (단순 UI는 구현 직후 테스트 허용)
의존성 절단을 우선합니다. 화면(뷰)과 로직 분리, API 모킹, View-Model(화면 데이터 계약) 선정의로 대기 없이 시작합니다.
결정론성을 유지합니다. 시간·랜덤·네트워크·WS는 고정/모킹하여 플래키(간헐 실패)를 허용하지 않습니다.
아키텍처 규율 준수: 아키텍처 경계(예: Public API만 import)를 테스트에도 동일 적용합니다.


2) 선행 개발 루틴(Design/API 없이 시작)
Definition of Ready(DoR)
사용자 스토리와 수용 기준을 문장으로 정리합니다(가시성·상호작용·상태변화 3축).
화면이 소비할 View-Model 필드/타입/기본값을 합의합니다.
실패하는 테스트 설계(최소 3~5개)
접근성 쿼리(역할/이름/라벨) 우선, 초기엔 data-test-id를 보조로 사용합니다.
구현 세부(클래스명/DOM 구조)에 의존하지 않습니다.
최소 구현으로 Green
단순 태그와 테스트 선택자만으로 기능을 충족합니다(스타일·복잡 마크업 보류).
Refactor
중복 제거, 의도 드러내기, 성능·a11y 개선. 테스트는 그대로 통과해야 합니다.
마크업/디자인 반영
실제 마크업을 적용하되, 기존 data-test-id/접근성 계약을 유지합니다(테스트 안정성 보장).
실 API 연결
Axios 호출부는 API Layer에서만 처리하고, 서버 DTO를 View-Model로 변환합니다. 화면 코드는 수정하지 않습니다.
회고/기록
플래키 원인, 대기 시간 감소 등 학습 내용을 기록하고 체크리스트를 갱신합니다.


3) 테스트 피라미드 (무엇을, 어디서, 어떻게)
단위(Unit) — 최다
대상: 도메인 규칙, 변환/정규화, 셀렉터, 순수 유틸.
원칙: 사이드이펙트 없음, 입력→출력과 경계값·에러 분기 검증.
컴포넌트(Component) — 행동 중심
대상: 버튼·폼·필터 등 상호작용 UI/훅.
검증: 가시성/상호작용/상태 전파, 접근성 속성. 구현 세부 노출 금지.
통합(Integration) — 사용자 흐름
대상: 라우팅, 상태/캐시 상호작용, 큰 블록 조합.
원칙: 네트워크·WS는 모킹. 시나리오 2~3개(happy+edge).
E2E(스모크) — 최소 핵심 경로
대상: 로그인→핵심 기능 1~2개→로그아웃.
느리거나 불안정한 시나리오는 과감히 통합 테스트로 하향합니다.


4) 의존성 제거 전략(핵심 기술)
디자인/마크업 독립
테스트는 의미 기반 쿼리(role/name/label) 우선, 구조·스타일 변화에 둔감하게 작성합니다.
안정성을 위해 data-test-id 네이밍 규약을 사용합니다(예: 컴포넌트-의미-역할).
API 독립
View-Model 우선 정의: 화면이 요구하는 필드/타입을 먼저 확정합니다.
가짜 데이터(Mock) 로 기능을 100% 완성한 뒤, 나중에 API Layer에서만 DTO→View-Model 변환을 적용합니다.
시간/랜덤/WS 독립
타이머·난수는 고정하고, WebSocket은 이벤트 시퀀스를 시뮬레이션하여 결정론화합니다.


5) 작성 규칙(팀 표준)
행동 언어로 서술합니다: "사용자는 …할 수 있다", "클릭하면 …된다".
테스트 1건 = 하나의 의도: 복합 검증은 분리하여 가독성을 유지합니다.
스냅샷 최소화: 잦은 마크업 변경에 취약한 전체 스냅샷 대신, 의미 있는 결과를 검증합니다.
안정 선택자: class/구조가 아닌 접근성 쿼리 + data-test-id를 사용합니다.
Ant Design: 테스트 안정성과 토큰 일관성을 위해 래핑 컴포넌트(Props 안정화)를 사용합니다.
상태 관리: Redux Persist에 민감정보 저장 금지. 테스트에서는 스토어 프리셋/모킹으로 결정론성 확보.
아키텍처 경계: 테스트도 Public API만 import하며, 내부 경로 직접 참조를 금지합니다.


6) 커버리지·품질 게이트
목표치: 전체 70%+, 핵심 도메인 85%+.
게이트: 타입체크 통과, ESLint 무경고(아키텍처 경계 포함), 순환 의존 0, E2E 스모크 통과.
플래키 제로 정책: 간헐 실패 발생 시 즉시 원인 기록·격리, 해결 전 병합 보류.


7) PR 규칙·체크리스트(TDD 관점)
수용 기준을 실패하는 테스트로 선제화(최소 3~5개 핵심 시나리오).
디자인/마크업 없이도 Green(선행 개발 완료).
API는 모킹으로 기능 100% 구현, 실제 연결은 API Layer 단일 변환.
접근성 쿼리·data-test-id 기반으로 안정적이며 플래키 없음.
성능·접근성 회귀 없음, 문서/체크리스트 갱신.
아키텍처 경계 준수(상향 의존/내부 import 없음).


8) 2주 도입 로드맵
W1: 파일럿 기능 선정 → DoR·View-Model 합의 → 실패 테스트 3~5개 → 최소 구현→Green.
W2: 통합/E2E 스모크 추가 → 실제 API 연결(단일 변환 지점) → 회고(대기시간·핫픽스·리뷰 시간/충돌 건수 지표).


9) 안티패턴과 대응
UI 전체 스냅샷 남용 → 행동 기반 검증으로 전환.
클래스/DOM 구조 의존 → 접근성 쿼리·data-test-id로 교체.
E2E 과투자 → 통합 테스트로 하향, 핵심 경로만 E2E 유지.
화면↔API 강결합 → API Layer에서 변환, 화면은 View-Model만 참조.
내부 경로 import → Public API 경유로 교정.


10) 정의(용어)
View-Model: 화면이 소비하는 데이터 계약(필드/타입/기본값). 서버 DTO와 분리합니다.
테스트 선택자(Test Selector): UI/마크업 변경에도 안정적인 테스트용 속성입니다.
플래키(Flaky): 동일 코드가 시점/환경에 따라 간헐 실패하는 테스트입니다.


11) 성공 지표(정량)
평균 리드타임 단축, 디자인/API 대기시간 감소.
선행 개발 비율(디자인·API 없이 Green까지 완료한 태스크 비중).
출시 후 1주 내 FE 긴급 핫픽스 건수 감소.
PR당 변경 파일 수·충돌 빈도 감소, 리뷰 시간 단축.


12) 운영 메모
기획 변경은 테스트 업데이트 → 실행 → 리팩터 순서로 반영합니다(문서보다 테스트 우선).
접근성은 테스트 항목에 포함하여 회귀를 차단합니다.
아키텍처 문서(FSD)의 의존 경계·Public API 규칙을 본 지침과 함께 준수합니다.



최종 업데이트: 2025-08-18 · 문서 소유자(Code Owner): (지정 필요)
부록 — AI 에이전트 활용 지침 (TDD 친화)
1) 운영 원칙
테스트가 명세: 에이전트 작업 시작은 항상 실패 테스트(수용기준)부터.
작게·자주: 변경 파일·라인수 상한(예: ≤5파일/≤300라인)과 의존성 추가 금지 기본.
계약 우선: View–Model 스키마, Public API, 오류 모델(AppError)을 입력으로 고정.
결정론성: 네트워크·시간·랜덤·WS는 모킹/고정. 플래키 테스트 발견 시 즉시 차단.
2) 태스크 카드(에이전트 입력) 포맷
Context: 관련 파일 경로, Public API, View–Model 스키마, 에러 규칙, 디자인 토큰 링크
Acceptance: Given/When/Then 3~5개(가시성·상호작용·상태변화)
Constraints: 파일/라인 상한, 금지사항(새 deps/전역 상태 변경/내부 경로 import), 성능·접근성 목표
Artifacts: 테스트 파일 목록, 생성/수정 대상 파일 목록, 커밋 메시지 규약(Conventional)
3) 표준 워크플로우 (R-G-R + 트라이어드)
Planner(요청 정제): DoR/수용기준/스키마 확정 → 태스크 카드 생성
Coder(구현): 실패 테스트 → 최소 구현 → Green → 리팩터(의미 드러내기·a11y)
Reviewer(검수): 린트/타입/커버리지/경계 규칙/플래키 검사 → 요약 코멘트 생성

역할은 사람/에이전트 혼합 가능. 실패 3회 시 원인 요약 + 대안 2가지 필수.
4) 프롬프트 최소 템플릿
Repo 맥락: 아키텍처 규칙(레이어, Public API), TDD 원칙, 스타일 가이드 요점
입력 산출물: 테스트 코드 → 구현 코드 → 리팩터 diff → 자기검증 로그 순으로 제시
금지: 내부 파일 직접 import, 스냅샷 남용, 클래스/구조 의존 쿼리
5) 테스트 규칙(에이전트 전용 체크)
접근성 쿼리 우선 + data-test-id 보조(네이밍: 컴포넌트-의미-역할)
하나의 테스트 = 하나의 의도, 느린/취약한 플로우는 통합 테스트로 하향
API 모킹 합의: DTO 예시 ↔ View–Model 변환표(키 매핑/기본값/에러 코드) 포함
WS 시뮬레이션: 고정 이벤트 시퀀스, 재접속/백오프 케이스 포함
6) 품질 게이트(자동 코멘트 기준)
빌드·타입·린트 통과, 경계 위반 0, 순환 의존 0
커버리지: 전체 70%+, 도메인 85%+ (미달 시 결손 라인 목록/사유 첨부)
플래키 0: 동일 작업 3회 반복 실행 결과 동일해야 함
접근성 스모크: 역할/이름/라벨 필수 경로 검증
7) 보안·컴플라이언스
비밀값/개인정보/내부 URL은 프롬프트에 포함 금지(.env.example로 치환)
제3자 코드 삽입·라이선스 텍스트 생성 금지(라이선스 불명 시 사용 금지)
로그/코멘트의 민감정보 자동 마스킹
8) 실패·롤백·기록
3회 실패 룰: 오류 유형(요구 불명/환경/제약 위반/플래키) 분류 → 다음 시도 전략 제시
부분 롤백: 새 테스트 유지, 구현만 되돌림(회귀 방지)
MEMORY.md: [날짜/요청/핵심 해결책/의존성 제거 포인트/리스크]를 자동 요약해 추가

