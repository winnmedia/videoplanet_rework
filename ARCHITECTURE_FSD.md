ARCHITECTURE_FSD.md — VideoPlanet 개발수칙 (v1.1.0)

본 문서는 Feature-Sliced Design(FSD) + Clean Architecture의 핵심 규칙만을 다룹니다. 운영·프로세스·테스트·보안 등 일반 규범은 

DEVELOPMENT_RULES.md를 따릅니다.

1) Why? (도입 배경 및 목표)
이 아키텍처를 도입하는 이유는 단순히 코드를 정리하는 것을 넘어, 다음과 같은 명확한 목표를 달성하기 위함입니다:

지속 가능한 성장: 프로젝트 규모가 커져도 복잡도가 급증하는 것을 막고, 예측 가능한 유지보수 비용을 유지합니다.

최고의 개발 경험: 신규 입사자가 빠르게 적응하고, 개발자가 불필요한 고민 없이 비즈니스 로직에 집중할 수 있는 환경을 제공합니다.


팀 생산성 극대화: 명확한 경계를 통해 팀의 병렬적인 작업을 지원하고, 코드 충돌과 커뮤니케이션 비용을 최소화합니다.

2) 목적

예측 가능한 변경과 팀 병렬 작업을 보장하고, 의존 경계와 공개 인터페이스를 통해 변경의 파급효과를 최소화합니다.

3) TL;DR

레이어(상→하만 의존): app → processes → widgets → features → entities → shared 


Public API만 import: 슬라이스 외부 노출은 index.ts (배럴)로 한정합니다.

도메인 순수성: entities는 특정 UI 프레임워크(React, Next.js)에 의존하지 않습니다.


린트로 강제: 상향 의존·내부 파일 직접 import를 CI 단계에서 금지합니다(필수).

4) 배치 기준 (결정 트리)
코드를 배치할 때 아래의 기준을 따르며, 시각적인 플로우차트 다이어그램을 참고하십시오.


라우팅 및 페이지 진입점: → app/ (Next.js App Router) 


핵심 도메인 데이터/규칙/상태: → entities/<domain> 


사용자 행동(버튼·폼) UI/로직: → features/<feature> 


여러 화면에서 쓰는 큰 UI 블록: → widgets/<block> 


여러 페이지에 걸친 복합 여정: → processes/<flow> (예: 다단계 결제, 온보딩 튜토리얼) 


완전 범용 자산(UI·유틸·타입 등): → shared/* 


애매할 때: 

"프레임워크 없이도 동작해야 하는 핵심 비즈니스 규칙인가?" → 

entities 

"사용자의 특정 행동을 유발하는 UI와 그 로직인가?" → 

features 

유효성 검사(Validation): 핵심 비즈니스 규칙(e.g., ID 중복)은 entities에, UI 종속적인 형식 검사(e.g., 이메일 포맷)는 features에 배치합니다.

5) 네이밍 및 스타일링
네이밍: 폴더와 슬라이스는 kebab-case로, 컴포넌트와 관련 파일은 PascalCase.tsx로 작성합니다.

스타일링: 스타일 코드는 컴포넌트 파일과 함께 배치(co-location)하며, 전역 스타일 및 디자인 토큰은 shared/styles에 중앙 관리합니다.

6) 의존·임포트 규칙

허용 방향: 상위 레이어 → 하위 레이어만 가능합니다.


금지: 하위→상위 import, 동일 레벨 슬라이스 간 임의 참조, 내부 파일 직접 import를 엄격히 금지합니다.


원칙: 모든 외부 참조는 항상 해당 슬라이스의 **배럴(index.ts) 파일(Public API)**을 경유해야 합니다.

7) 데이터·상태 원칙

서버 캐시/패칭: RTK Query(또는 동급) 사용을 권장합니다.


전역 도메인 상태: 정규화된 데이터와 관련 비즈니스 로직은 entities에 배치합니다.


일시적/UI 상태: 특정 기능에 한정된 폼 상태나 UI 상태는 features 내부에 둡니다.


DTO→도메인 변환: 서버로부터 받은 DTO(Data Transfer Object)는 entities의 전용 변환 레이어에서 도메인 모델로 일원화하여 변환합니다.

8) 금지/권장 패턴
금지 🚫

배럴 파일을 우회하여 내부 파일 직접 import 


shared 레이어에 특정 도메인 지식이나 상태 유입 


features 레이어에 장기적으로 유지되어야 할 핵심 도메인 상태 상주 

entities 내부에서 React/Next.js 등 UI 프레임워크 API import

권장 ✅

컴포넌트·훅의 Props와 반환값(계약면) 최소화 

런타임 스키마 검증(e.g., Zod) 후 도메인 모델로 변환 

디자인 토큰과 공용 UI 컴포넌트의 사용 일원화 

9) 테스트 원칙

단위 테스트: 순수한 도메인 규칙, 정규화 로직, 리듀서/셀렉터 등 entities를 중심으로 작성합니다. 프레임워크에 비의존적이므로 Node.js 환경에서 테스트합니다.


컴포넌트 테스트: 사용자의 행동과 직접 관련된 UI의 상호작용 및 접근성을 테스트합니다 (features/ui 중심).


통합(E2E) 테스트: 핵심 사용자 여정(가입, 로그인, 결제 등)에 대한 스모크 테스트를 수행합니다.


규칙: 테스트 코드는 결정론적이어야 하며, 항상 배럴 파일을 통해 import하고, 스냅샷 테스트를 남용하지 않습니다.

10) 린트·정적 분석

경계 강제: 상향 의존 및 내부 파일 직접 import 금지 룰을 ESLint에 필수로 설정합니다.


순환 의존 금지: 순환 의존성 검출(e.g., dpdm, madge)을 CI 단계에서 상시 체크하여 0건을 유지합니다.


타입·스타일 규칙: TypeScript, Prettier, Stylelint 등의 규칙을 PR 게이트에서 강제합니다.

11) 마이그레이션

점진적 적용: 새로 작성되는 코드는 100% FSD를 따르는 스트랭글러 패턴을 사용합니다.


자산 우선 이전: 범용적으로 사용되는 자산은 shared로, 핵심 도메인 모델은 entities로 우선적으로 이전합니다.


강도 점진 상향: 린트 규칙의 레벨을 warn에서 시작하여 점진적으로 error로 상향 조정합니다.

12) PR 체크리스트 (FSD 전용)
[ ] 레이어 규칙을 준수했는가? (상향 의존, 동일 레벨 임의 참조 없음) 

[ ] 내부 파일을 직접 import하지 않고 배럴 파일만 사용했는가? 

[ ] 도메인 상태/규칙은 

entities에, 일시적/폼 상태는 features에 위치하는가? 

[ ] DTO→도메인 변환이 전용 레이어에서 일관되게 처리되었는가? 

[ ] 테스트 코드가 배럴 파일을 통해 import하며 결정론적으로 작성되었는가? 

13) 문서·책임

Code Owner를 지정하여 본 문서의 단일 소스를 유지합니다.

구조 및 규칙에 대한 변경은 

ADR(Architecture Decision Record) 작성을 필수로 하며, 리뷰 후 반영합니다.

일반 개발 규칙(

DEVELOPMENT_RULES.md)에는 본 문서의 링크(TL;DR)만 유지합니다.

버전: 1.1.0
최종 업데이트: 2025-08-23