/**
 * RBAC System Integration Tests with MSW
 * 
 * 권한 시스템 복구 후 프론트엔드 UX 개선 방안 테스트
 * - 5-tier RBAC (Owner→Admin→Editor→Reviewer→Viewer) 검증
 * - 사용자 데이터 격리 시스템 테스트
 * - 보안 이벤트 모니터링 검증
 * - 접근성 준수 권한 오류 처리 테스트
 */

import { rest } from 'msw'
import { setupServer } from 'msw/node'
import { render, screen, waitFor, within } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { rbacHandlers, setMockUser, mockUsers, mockProjects } from './rbac-handlers'
import { RBACContext, RBACContextValue } from '@/shared/lib/rbac-system'
import { DataIsolationProvider } from '@/shared/ui/DataIsolation'
import { SecurityDashboard } from '@/widgets/SecurityDashboard'
import { AccessibleErrorBoundary } from '@/shared/ui/AccessibilityErrorHandler'
import { RoleGuard, PermissionGuard } from '@/shared/ui/RoleGuard'

// MSW server setup
const server = setupServer(...rbacHandlers)

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

// Test component that uses multiple RBAC features
const TestApplication = ({ userRole }: { userRole: keyof typeof mockUsers }) => {
  const user = mockUsers[userRole]
  const contextValue: RBACContextValue = {
    user,
    permissions: user.permissions,
    loading: false,
    projectId: '101'
  }

  return (
    <RBACContext.Provider value={contextValue}>
      <DataIsolationProvider isolationLevel="user">
        <AccessibleErrorBoundary>
          <div data-testid="app-container">
            {/* Role-based navigation */}
            <nav role="navigation" aria-label="메인 네비게이션">
              <RoleGuard requiredRole="viewer">
                <button data-testid="projects-nav">프로젝트</button>
              </RoleGuard>
              
              <RoleGuard requiredRole="editor">
                <button data-testid="content-nav">콘텐츠 편집</button>
              </RoleGuard>
              
              <RoleGuard requiredRole="admin">
                <button data-testid="members-nav">멤버 관리</button>
              </RoleGuard>
              
              <RoleGuard requiredRole="admin">
                <SecurityDashboard />
              </RoleGuard>
            </nav>

            {/* Permission-based actions */}
            <main>
              <PermissionGuard requiredPermission="project:edit">
                <button data-testid="edit-project">프로젝트 편집</button>
              </PermissionGuard>
              
              <PermissionGuard requiredPermission="project:delete">
                <button data-testid="delete-project">프로젝트 삭제</button>
              </PermissionGuard>
              
              <PermissionGuard requiredPermission="security:read">
                <div data-testid="security-section">보안 모니터링</div>
              </PermissionGuard>
            </main>
          </div>
        </AccessibleErrorBoundary>
      </DataIsolationProvider>
    </RBACContext.Provider>
  )
}

describe('RBAC System Integration Tests', () => {
  describe('5-Tier Role Hierarchy Tests', () => {
    it('should enforce Owner role permissions correctly', () => {
      render(<TestApplication userRole="owner" />)
      
      // Owner should see all navigation items
      expect(screen.getByTestId('projects-nav')).toBeInTheDocument()
      expect(screen.getByTestId('content-nav')).toBeInTheDocument()
      expect(screen.getByTestId('members-nav')).toBeInTheDocument()
      
      // Owner should have all action permissions
      expect(screen.getByTestId('edit-project')).toBeInTheDocument()
      expect(screen.getByTestId('delete-project')).toBeInTheDocument()
      expect(screen.getByTestId('security-section')).toBeInTheDocument()
    })

    it('should enforce Admin role permissions correctly', () => {
      render(<TestApplication userRole="admin" />)
      
      // Admin should see admin-level and below navigation
      expect(screen.getByTestId('projects-nav')).toBeInTheDocument()
      expect(screen.getByTestId('content-nav')).toBeInTheDocument()
      expect(screen.getByTestId('members-nav')).toBeInTheDocument()
      
      // Admin should have edit permissions but not delete
      expect(screen.getByTestId('edit-project')).toBeInTheDocument()
      expect(screen.queryByTestId('delete-project')).not.toBeInTheDocument()
      expect(screen.getByTestId('security-section')).toBeInTheDocument()
    })

    it('should enforce Editor role permissions correctly', () => {
      render(<TestApplication userRole="editor" />)
      
      // Editor should see editor-level and below navigation
      expect(screen.getByTestId('projects-nav')).toBeInTheDocument()
      expect(screen.getByTestId('content-nav')).toBeInTheDocument()
      expect(screen.queryByTestId('members-nav')).not.toBeInTheDocument()
      
      // Editor should have edit permissions
      expect(screen.getByTestId('edit-project')).toBeInTheDocument()
      expect(screen.queryByTestId('delete-project')).not.toBeInTheDocument()
      expect(screen.queryByTestId('security-section')).not.toBeInTheDocument()
    })

    it('should enforce Reviewer role permissions correctly', () => {
      render(<TestApplication userRole="reviewer" />)
      
      // Reviewer should only see basic navigation
      expect(screen.getByTestId('projects-nav')).toBeInTheDocument()
      expect(screen.queryByTestId('content-nav')).not.toBeInTheDocument()
      expect(screen.queryByTestId('members-nav')).not.toBeInTheDocument()
      
      // Reviewer should have no edit permissions
      expect(screen.queryByTestId('edit-project')).not.toBeInTheDocument()
      expect(screen.queryByTestId('delete-project')).not.toBeInTheDocument()
      expect(screen.queryByTestId('security-section')).not.toBeInTheDocument()
    })

    it('should enforce Viewer role permissions correctly', () => {
      render(<TestApplication userRole="viewer" />)
      
      // Viewer should only see basic navigation
      expect(screen.getByTestId('projects-nav')).toBeInTheDocument()
      expect(screen.queryByTestId('content-nav')).not.toBeInTheDocument()
      expect(screen.queryByTestId('members-nav')).not.toBeInTheDocument()
      
      // Viewer should have no action permissions
      expect(screen.queryByTestId('edit-project')).not.toBeInTheDocument()
      expect(screen.queryByTestId('delete-project')).not.toBeInTheDocument()
      expect(screen.queryByTestId('security-section')).not.toBeInTheDocument()
    })
  })

  describe('API Integration Tests', () => {
    beforeEach(() => {
      setMockUser('viewer') // Default to most restrictive role
    })

    it('should handle authentication flow correctly', async () => {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'owner@videoplanet.com',
          password: 'password'
        })
      })
      
      const data = await response.json()
      
      expect(response.status).toBe(200)
      expect(data.success).toBe(true)
      expect(data.data.user.role).toBe('owner')
      expect(data.data.tokens.accessToken).toContain('mock_token')
    })

    it('should enforce project access control', async () => {
      // Test as viewer (most restrictive)
      setMockUser('viewer')
      
      const response = await fetch('/api/projects/102') // Project not owned by viewer
      expect(response.status).toBe(403)
      
      const errorData = await response.json()
      expect(errorData.code).toBe('PERMISSION_DENIED')
      expect(errorData.requiredPermission).toBe('project:read')
    })

    it('should filter projects based on user isolation level', async () => {
      setMockUser('editor')
      
      const response = await fetch('/api/projects')
      const data = await response.json()
      
      expect(response.status).toBe(200)
      expect(data.data.projects).toHaveLength(1) // Editor only sees their own project
      expect(data.data.projects[0].id).toBe('103')
    })

    it('should prevent unauthorized security dashboard access', async () => {
      setMockUser('editor')
      
      const eventsResponse = await fetch('/api/security/events')
      expect(eventsResponse.status).toBe(403)
      
      const metricsResponse = await fetch('/api/security/metrics')
      expect(metricsResponse.status).toBe(403)
    })

    it('should allow admin access to security dashboard', async () => {
      setMockUser('admin')
      
      const eventsResponse = await fetch('/api/security/events')
      expect(eventsResponse.status).toBe(200)
      
      const eventsData = await eventsResponse.json()
      expect(eventsData.success).toBe(true)
      expect(eventsData.data.events).toBeDefined()
      
      const metricsResponse = await fetch('/api/security/metrics')
      expect(metricsResponse.status).toBe(200)
      
      const metricsData = await metricsResponse.json()
      expect(metricsData.data.totalEvents).toBeGreaterThan(0)
    })

    it('should prevent unauthorized project deletion', async () => {
      setMockUser('viewer')
      
      const response = await fetch('/api/projects/101', { method: 'DELETE' })
      expect(response.status).toBe(403)
      
      const errorData = await response.json()
      expect(errorData.requiredPermission).toBe('project:delete')
    })

    it('should handle member invitation permissions', async () => {
      setMockUser('viewer') // Viewer cannot invite
      
      const response = await fetch('/api/projects/101/members', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId: '6', role: 'viewer' })
      })
      
      expect(response.status).toBe(403)
      
      const errorData = await response.json()
      expect(errorData.requiredPermission).toBe('member:invite')
    })
  })

  describe('Error Handling and Accessibility Tests', () => {
    const ErrorTestComponent = ({ triggerError }: { triggerError: boolean }) => {
      if (triggerError) {
        throw new Error('PERMISSION_DENIED: Test permission error')
      }
      return <div>Content loaded successfully</div>
    }

    it('should handle permission errors accessibly', () => {
      const user = mockUsers.viewer
      const contextValue: RBACContextValue = {
        user,
        permissions: user.permissions,
        loading: false
      }

      render(
        <RBACContext.Provider value={contextValue}>
          <AccessibleErrorBoundary>
            <ErrorTestComponent triggerError={true} />
          </AccessibleErrorBoundary>
        </RBACContext.Provider>
      )

      // Should display accessible error message
      expect(screen.getByRole('alert')).toBeInTheDocument()
      expect(screen.getByText('오류가 발생했습니다')).toBeInTheDocument()
      
      // Should have proper ARIA attributes
      const alert = screen.getByRole('alert')
      expect(alert).toHaveAttribute('aria-live', 'assertive')
      expect(alert).toHaveAttribute('aria-atomic', 'true')
      
      // Should provide recovery actions
      expect(screen.getByRole('button', { name: '다시 시도' })).toBeInTheDocument()
    })

    it('should announce security events to screen readers', async () => {
      setMockUser('admin')
      
      render(<SecurityDashboard />)
      
      await waitFor(() => {
        expect(screen.getByText('보안 모니터링 대시보드')).toBeInTheDocument()
      })
      
      // Check for security event alerts
      const alerts = await screen.findAllByRole('alert')
      expect(alerts.length).toBeGreaterThan(0)
    })

    it('should provide keyboard navigation for error recovery', async () => {
      const user = userEvent.setup()
      const mockUser = mockUsers.viewer
      const contextValue: RBACContextValue = {
        user: mockUser,
        permissions: mockUser.permissions,
        loading: false
      }

      render(
        <RBACContext.Provider value={contextValue}>
          <AccessibleErrorBoundary>
            <ErrorTestComponent triggerError={true} />
          </AccessibleErrorBoundary>
        </RBACContext.Provider>
      )

      const retryButton = screen.getByRole('button', { name: '다시 시도' })
      
      // Test keyboard focus
      await user.tab()
      expect(retryButton).toHaveFocus()
      
      // Test keyboard activation
      await user.keyboard('{Enter}')
      // Button should have been activated
    })
  })

  describe('Data Isolation Scenarios', () => {
    it('should isolate user data correctly for different roles', async () => {
      // Test with editor role (should only see own projects)
      setMockUser('editor')
      
      const response = await fetch('/api/projects')
      const data = await response.json()
      
      // Editor should only see their own project (id: 103)
      expect(data.data.projects).toHaveLength(1)
      expect(data.data.projects[0].id).toBe('103')
      expect(data.data.projects[0].userId).toBe('3') // editor's id
    })

    it('should allow supervisory access for admin roles', async () => {
      setMockUser('admin')
      
      const response = await fetch('/api/projects')
      const data = await response.json()
      
      // Admin should see all projects
      expect(data.data.projects).toHaveLength(mockProjects.length)
    })

    it('should handle cross-user data access attempts', async () => {
      setMockUser('editor')
      
      // Try to access a project owned by another user
      const response = await fetch('/api/projects/101') // Owned by user '1'
      expect(response.status).toBe(403)
      
      const errorData = await response.json()
      expect(errorData.code).toBe('PERMISSION_DENIED')
    })
  })

  describe('Security Event Monitoring Tests', () => {
    it('should log permission denied events', async () => {
      setMockUser('viewer')
      
      // Trigger a permission denied scenario
      const response = await fetch('/api/test/rbac/scenario/permission-denied')
      expect(response.status).toBe(403)
      
      const errorData = await response.json()
      expect(errorData.code).toBe('PERMISSION_DENIED')
      expect(errorData.timestamp).toBeDefined()
    })

    it('should track unauthorized access attempts', async () => {
      const response = await fetch('/api/test/rbac/scenario/unauthorized-access')
      expect(response.status).toBe(401)
      
      const errorData = await response.json()
      expect(errorData.code).toBe('UNAUTHORIZED')
    })

    it('should monitor role insufficiency events', async () => {
      setMockUser('viewer')
      
      const response = await fetch('/api/test/rbac/scenario/role-insufficient')
      expect(response.status).toBe(403)
      
      const errorData = await response.json()
      expect(errorData.code).toBe('ROLE_INSUFFICIENT')
      expect(errorData.requiredRole).toBe('admin')
      expect(errorData.currentRole).toBe('viewer')
    })

    it('should filter security events by severity for admins', async () => {
      setMockUser('admin')
      
      const response = await fetch('/api/security/events?severity=high')
      const data = await response.json()
      
      expect(response.status).toBe(200)
      expect(data.data.events.every((event: any) => event.severity === 'high')).toBe(true)
    })
  })

  describe('Performance and UX Tests', () => {
    it('should load role-based UI elements within performance budget (INP ≤ 200ms)', async () => {
      const startTime = performance.now()
      
      render(<TestApplication userRole="admin" />)
      
      // Wait for all role-based elements to render
      await waitFor(() => {
        expect(screen.getByTestId('members-nav')).toBeInTheDocument()
      })
      
      const endTime = performance.now()
      const renderTime = endTime - startTime
      
      // Should render within 200ms INP budget
      expect(renderTime).toBeLessThan(200)
    })

    it('should handle loading states gracefully', () => {
      const user = mockUsers.admin
      const contextValue: RBACContextValue = {
        user,
        permissions: user.permissions,
        loading: true // Simulate loading state
      }

      render(
        <RBACContext.Provider value={contextValue}>
          <RoleGuard requiredRole="admin">
            <div>Admin Content</div>
          </RoleGuard>
        </RBACContext.Provider>
      )

      expect(screen.getByRole('status')).toBeInTheDocument()
      expect(screen.getByText('권한 확인 중...')).toBeInTheDocument()
    })

    it('should provide clear error messages for different failure scenarios', async () => {
      setMockUser('viewer')
      
      // Test different error scenarios
      const scenarios = [
        { endpoint: '/api/test/rbac/scenario/permission-denied', expectedCode: 'PERMISSION_DENIED' },
        { endpoint: '/api/test/rbac/scenario/unauthorized-access', expectedCode: 'UNAUTHORIZED' },
        { endpoint: '/api/test/rbac/scenario/role-insufficient', expectedCode: 'ROLE_INSUFFICIENT' }
      ]
      
      for (const scenario of scenarios) {
        const response = await fetch(scenario.endpoint)
        const data = await response.json()
        
        expect(data.code).toBe(scenario.expectedCode)
        expect(data.timestamp).toBeDefined()
      }
    })
  })
})

describe('Integration Test Cleanup and Validation', () => {
  it('should reset user state between tests', () => {
    setMockUser('owner')
    expect(fetch('/api/auth/me')).resolves.toBeTruthy()
    
    setMockUser(null)
    expect(fetch('/api/auth/me')).rejects.toBeTruthy()
  })

  it('should validate MSW handler coverage', () => {
    // Ensure all critical RBAC endpoints are covered
    const requiredHandlers = [
      'POST /api/auth/login',
      'GET /api/auth/me',
      'GET /api/permissions/check',
      'GET /api/projects',
      'DELETE /api/projects/:projectId',
      'GET /api/security/events',
      'GET /api/security/metrics'
    ]
    
    // This test ensures we have MSW handlers for all critical endpoints
    expect(rbacHandlers.length).toBeGreaterThan(requiredHandlers.length - 1)
  })
})